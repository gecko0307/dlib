/*
Copyright (c) 2011-2013 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module dlib.image.io.png;

private
{
    import std.stdio;
    import std.math;
    import std.zlib;

    import dlib.math.utils;

    import dlib.image.image;
    import dlib.image.io.zstream;
}

// uncomment this to see debug messages:
//version = PNGDebug;

static const ubyte[8] PNGSignature = [137, 80, 78, 71, 13, 10, 26, 10];
static const ubyte[4] IHDR = ['I', 'H', 'D', 'R'];
static const ubyte[4] IEND = ['I', 'E', 'N', 'D'];
static const ubyte[4] IDAT = ['I', 'D', 'A', 'T'];
static const ubyte[4] PLTE = ['P', 'L', 'T', 'E'];
static const ubyte[4] tRNS = ['t', 'R', 'N', 'S'];
static const ubyte[4] bKGD = ['b', 'K', 'G', 'D'];
static const ubyte[4] tEXt = ['t', 'E', 'X', 't'];
static const ubyte[4] iTXt = ['i', 'T', 'X', 't'];
static const ubyte[4] zTXt = ['z', 'T', 'X', 't'];

enum ColorType: ubyte
{
    Greyscale = 0,      // allowed bit depths: 1, 2, 4, 8 and 16
    RGB = 2,            // allowed bit depths: 8 and 16
    Palette = 3,        // allowed bit depths: 1, 2, 4 and 8
    GreyscaleAlpha = 4, // allowed bit depths: 8 and 16
    RGBA = 6,           // allowed bit depths: 8 and 16
    Any = 7             // one of the above
}

enum FilterMethod: ubyte
{
    None = 0,
    Sub = 1,
    Up = 2,
    Average = 3,
    Paeth = 4
}

struct PNGChunk
{
    union
    {
        uint length;
        ubyte[4] length_bytes;
    }
    
    ubyte[4] type;
    ubyte[] data;

    union
    {
        uint crc;
        ubyte[4] crc_bytes;
    }
}

struct PNGHeader
{
    union
    {
        struct 
        {
            uint width;
            uint height;
            ubyte bitDepth;
            ubyte colorType;
            ubyte compressionMethod;
            ubyte filterMethod;
            ubyte interlaceMethod;
        };
        ubyte[13] bytes;
    }
}

SuperImage loadPNG(string filename)
{
    SuperImage img;

    auto f = new File(filename, "r");

    PNGChunk readChunk()
    {
        PNGChunk chunk;

        f.rawRead(chunk.length_bytes);
        chunk.length = bigEndian(chunk.length);
        version(PNGDebug) writefln("Chunk length = %s", chunk.length);

        f.rawRead(chunk.type);
        version(PNGDebug) writefln("Chunk type = %s", cast(char[])chunk.type);

        if (chunk.length > 0)
        {
            chunk.data = new ubyte[chunk.length];
            f.rawRead(chunk.data);
        }
        version(PNGDebug) writefln("Chunk data.length = %s", chunk.data.length);

        f.rawRead(chunk.crc_bytes);
        chunk.crc = bigEndian(chunk.crc);
        uint calculatedCRC = crc32(chunk.type ~ chunk.data);

        version(PNGDebug) 
        {
            writefln("Chunk CRC = %s", chunk.crc);
            writefln("Calculated CRC = %s", calculatedCRC);
            writeln("-------------------");
        }

        //if (chunk.length)
        assert(chunk.crc == calculatedCRC, "PNG Error: CRC check failed");

        return chunk;
    }

    PNGHeader readHeader(ref PNGChunk chunk)
    {
        PNGHeader hdr;
        hdr.bytes = chunk.data;
        hdr.width = bigEndian(hdr.width);
        hdr.height = bigEndian(hdr.height);
        version(PNGDebug)
        { 
            writefln("width = %s", hdr.width);
            writefln("height = %s", hdr.height);
            writefln("bitDepth = %s", hdr.bitDepth);
            writefln("colorType = %s", hdr.colorType);
            writefln("compressionMethod = %s", hdr.compressionMethod);
            writefln("filterMethod = %s", hdr.filterMethod);
            writefln("interlaceMethod = %s", hdr.interlaceMethod);
            writeln("-------------------"); 
        }   
        return hdr;
    }

    ZlibDecodeStream inflator;

    ubyte[8] signatureBuffer;
    f.rawRead(signatureBuffer);
    version(PNGDebug) 
    {
        writeln("-------------------");
        writeln("PNG Signature: ", signatureBuffer);
        writeln("-------------------");
    }
    if (signatureBuffer != PNGSignature)
    {
        writefln("PNG error: file \"%s\" not a PNG", filename);
        f.close();
        return img;
    }

    ubyte[] buffer;
    //ubyte[] ilaceBuffer; // interlaced filtered scanlines
    ubyte[] pdata; // temp data for palette substitution

    ubyte[] palette;
    uint paletteSize = 0;

    PNGHeader hdr;

    PNGChunk chunk;
    while (chunk.type != IEND && !f.eof)
    {
        chunk = readChunk();

        if (chunk.type == IHDR)
        {
            hdr = readHeader(chunk);

            if (hdr.bitDepth != 8 && hdr.bitDepth != 16) 
            {
                writeln("PNG error: unsupported PNG bit depth"); 
                f.close(); 
                return img;
            }

            if (hdr.compressionMethod != 0) 
            {
                writeln("PNG error: unknown PNG compression method"); 
                f.close(); 
                return img;
            }

            if (hdr.filterMethod != 0) 
            {
                writeln("PNG error: unknown PNG filter method"); 
                f.close(); 
                return img;
            }

            if (hdr.interlaceMethod != 0) 
            {
                writeln("PNG error: interlacing is not supported"); 
                f.close(); 
                return img;
            }

            if (hdr.colorType == ColorType.Greyscale)
            {
                if (hdr.bitDepth == 8)
                    img = new ImageL8(hdr.width, hdr.height);
                else if (hdr.bitDepth == 16)
                    img = new ImageL16(hdr.width, hdr.height);
            }
            else if (hdr.colorType == ColorType.GreyscaleAlpha)
            {
                if (hdr.bitDepth == 8)
                    img = new ImageLA8(hdr.width, hdr.height);
                else if (hdr.bitDepth == 16)
                    img = new ImageLA16(hdr.width, hdr.height);
            }
            else if (hdr.colorType == ColorType.RGB)
            {
                if (hdr.bitDepth == 8)
                    img = new ImageRGB8(hdr.width, hdr.height);
                else if (hdr.bitDepth == 16)
                    img = new ImageRGB16(hdr.width, hdr.height);
            }
            else if (hdr.colorType == ColorType.RGBA)
            {
                if (hdr.bitDepth == 8)
                    img = new ImageRGBA8(hdr.width, hdr.height);
                else if (hdr.bitDepth == 16)
                    img = new ImageRGBA16(hdr.width, hdr.height);
            }
            else if (hdr.colorType == ColorType.Palette)
            {
                img = new ImageL8(hdr.width, hdr.height);
            }
            else
            {
                writeln("PNG error: unsupported PNG Color type (%s)", hdr.colorType); 
                f.close(); 
                return img;
            }

            version(PNGDebug)
            {
                writefln("img.width = %s", img.width);
                writefln("img.height = %s", img.height);
                writefln("img.bitDepth = %s", img.bitDepth);
                writefln("img.channels = %s", img.channels);
                writeln("-------------------"); 
            }

            // if (hdr.interlaceMethod == 1)
            // bufferLength = ((img.width * img.bpp + 7) / 8) * img.height + (img.height * 2); // guess

            uint bufferLength = ((img.width * img.bitDepth + 7) / 8) * img.height + img.height;
            buffer = new ubyte[bufferLength];

            //if (hdr.interlaceMethod == 1)
            //    ilaceBuffer.length = buffer.length - info.image.height;
            
            inflator = ZlibDecodeStream.create(buffer);

            version(PNGDebug) 
            {
                writefln("buffer.length = %s", bufferLength);
                writeln("-------------------"); 
            }
        }
        else if (chunk.type == IDAT)
        {
            inflator(chunk.data);
        }
        else if (chunk.type == PLTE)
        {
            palette = chunk.data;
        }
    }

    assert(inflator.hasEnded);
    buffer = inflator();

    f.close();

    //return (info.interlace == 0) ? reconstruct(buffer, info.image)
    //                             : deinterlace(buffer, ilaceBuffer, info.image);

    // apply filtering to the image data
    buffer = filter(img, buffer);
    if (buffer is null) return img;

    // if a palette is used, substitute target Colors
    if (hdr.colorType == ColorType.Palette)
    {
        if (palette.length == 0)
        {
            writefln("PNG error: palette chunk not found"); 
            return img;
        }
        img = new ImageRGB8(img.width, img.height);
        pdata = new ubyte[img.width * img.height * img.channels];
        for (int i = 0; i < buffer.length; ++i)
        {
            //assert(buffer[i]+2 < cast(int)paletteSize); // over reading palette
            assert(i*img.channels+2 < img.width * img.height * img.channels); // over reading final data
            pdata[i*img.channels+0] = palette[buffer[i]*3+0];
            pdata[i*img.channels+1] = palette[buffer[i]*3+1];
            pdata[i*img.channels+2] = palette[buffer[i]*3+2];
        }
        delete buffer;
        buffer = pdata;
    }

    img.data = buffer;
    
    return img;
}

void savePNG(SuperImage img, string filename)
in
{
    assert (img.data.length);
}
body
{
    assert(img.bitDepth == 8, "PNG error: only 8-bit images are supported by encoder");

    auto f = new File(filename, "w");

    void writeChunk(ubyte[4] chunkType, ubyte[] chunkData)
    {
        PNGChunk hdrChunk;
        hdrChunk.length = networkByteOrder(chunkData.length);
        hdrChunk.type = chunkType;
        hdrChunk.data = chunkData;
        hdrChunk.crc = networkByteOrder(crc32(chunkType ~ hdrChunk.data));
        f.rawWrite(hdrChunk.length_bytes);
        f.rawWrite(hdrChunk.type);
        if (chunkData.length)
            f.rawWrite(hdrChunk.data);
        f.rawWrite(hdrChunk.crc_bytes);
    }

    void writeHeader()
    {
        PNGHeader hdr;
        hdr.width = networkByteOrder(img.width);
        hdr.height = networkByteOrder(img.height);
        hdr.bitDepth = 8;
        if (img.channels == 4)
            hdr.colorType = ColorType.RGBA;
        else if (img.channels == 3)
            hdr.colorType = ColorType.RGB;
        else if (img.channels == 2)
            hdr.colorType = ColorType.GreyscaleAlpha;
        else if (img.channels == 1)
            hdr.colorType = ColorType.Greyscale;
        hdr.compressionMethod = 0;
        hdr.filterMethod = 0;
        hdr.interlaceMethod = 0;

        writeChunk(IHDR, hdr.bytes);
    }

    f.rawWrite(PNGSignature);
    writeHeader();

    //TODO: filtering
    ubyte[] raw = new ubyte[img.width * img.height * img.channels + img.height];
    foreach(y; 0..img.height)
    {
        auto rowStart = (img.height - y - 1) * (img.width * img.channels + 1);
        raw[rowStart] = 0; // No filter

        foreach(x; 0..img.width)
        {
            auto dataIndex = (y * img.width + x) * img.channels;
            auto rawIndex = rowStart + 1 + x * img.channels;

            foreach(ch; 0..img.channels)
                raw[rawIndex + ch] = img.data[dataIndex + ch];
        }
    }

    writeChunk(IDAT, cast(ubyte[])compress(raw));
    writeChunk(IEND, []);

    f.close();
}

/*
 * performs the paeth PNG filter from pixels values:
 *   a = back
 *   b = up
 *   c = up and back
 */
pure ubyte paeth(ubyte a, ubyte b, ubyte c)
{
    int p = a + b - c;
    int pa = abs(p - a);
    int pb = abs(p - b);
    int pc = abs(p - c);
    if (pa <= pb && pa <= pc) return a;
    else if (pb <= pc) return b;
    else return c;
}

ubyte[] filter(SuperImage img, ubyte[] ibuffer)
{
    ubyte[] tmp = ibuffer;
    uint dataSize = tmp.length;
    if (dataSize != img.width * img.height * img.channels + img.height)
    {
        writeln("PNG error: image size and data mismatch");
        return null;
    }

    auto buffer = new ubyte[dataSize - img.height];

    ubyte pback, pup, pupback, cbyte;

    for (int i = 0; i < img.height; ++i)
    {
        pback = 0;
        ubyte scanFilter = tmp[i * (img.width * img.channels + 1)]; // get the first byte of each scanline
        for (int j = 0; j < img.width; ++j)
        {
            for (int k = 0; k < img.channels; ++k)
            {
                if (i == 0)    pup = 0;
                else pup = buffer[((img.height-(i-1)-1) * img.width + j) * img.channels + k];
                if (j == 0)    pback = 0;
                else pback = buffer[((img.height-i-1) * img.width + j-1) * img.channels + k];
                if (i == 0 || j == 0) pupback = 0;
                else pupback = buffer[((img.height-(i-1)-1) * img.width + j - 1) * img.channels + k];
                
                // get the current byte from tmp
                cbyte = tmp[i * (img.width * img.channels + 1) + j * img.channels + k + 1];

                // filter, then set the current byte in data
                switch (scanFilter)
                {
                    case FilterMethod.None:
                        buffer[((img.height-i-1) * img.width + j) * img.channels + k] = cbyte;
                        break;
                    case FilterMethod.Sub:
                        buffer[((img.height-i-1) * img.width + j) * img.channels + k] = cast(ubyte)(cbyte + pback);
                        break;
                    case FilterMethod.Up:
                        buffer[((img.height-i-1) * img.width + j) * img.channels + k] = cast(ubyte)(cbyte + pup);
                        break;
                    case FilterMethod.Average:
                        buffer[((img.height-i-1) * img.width + j) * img.channels + k] = cast(ubyte)(cbyte + (pback + pup) / 2);
                        break;
                    case FilterMethod.Paeth:
                        buffer[((img.height-i-1) * img.width + j) * img.channels + k] = cast(ubyte)(cbyte + paeth(pback, pup, pupback));
                        break;
                    default:
                        writefln("PNG error: unknown scanline filter (%s)", scanFilter);
                        return null;
                }
            }
        }
    }

    return buffer;
}

uint crc32(ubyte[] buf, uint inCrc = 0)
{
    uint[256] generateTable()
    { 
        uint[256] table;
        uint crc;
        for (int i = 0; i < 256; i++)
        {
            crc = i;
            for (int j = 0; j < 8; j++)
                crc = crc & 1 ? (crc >> 1) ^ 0xEDB88320UL : crc >> 1;
            table[i] = crc;
        }
        return table;
    }

    static const uint[256] table = generateTable();

    uint crc;
    ubyte* byteBuf;

    crc = inCrc ^ 0xFFFFFFFF;
    byteBuf = buf.ptr;
    for (uint i = 0; i < buf.length; i++)
        crc = (crc >> 8) ^ table[(crc ^ byteBuf[i]) & 0xFF];

    return (crc ^ 0xFFFFFFFF);
}
