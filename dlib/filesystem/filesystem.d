/*
Copyright (c) 2014-2020 Martin Cejp, Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Copyright: Martin Cejp, Timur Gafarov 2014-2020.
 * License: $(LINK2 boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Martin Cejp, Timur Gafarov
 */
module dlib.filesystem.filesystem;

import std.datetime;
import std.range;
import std.regex;
import std.algorithm;
import std.string;

import dlib.core.stream;
import dlib.filesystem.dirrange;

/// File size type
alias FileSize = StreamSize;

/// If a file is readable, FileStat.permissions will have PRead bits set
enum PRead = 0x01;

/// If a file is writable, FileStat.permissions will have PWrite bits set
enum PWrite = 0x02;

/// If a file is executable, FileStat.permissions will have PExecute bits set
enum PExecute = 0x04;

/// Holds general information about a file or directory.
struct FileStat
{
    /// True if a file is not a directory
    bool isFile;
    
    /// True if a file is a directory
    bool isDirectory;
    
    /// File size. Valid only if isFile is true
    FileSize sizeInBytes;
    
    /// File creation date/time
    SysTime creationTimestamp;
    
    /// File modification date/time
    SysTime modificationTimestamp;
    
    /// Permissions of a file in a given filesystem. Bit combination of PRead, PWrite, PExecute
    int permissions;
}

/// A filesystem entry - file or directory
struct DirEntry
{
    /// Entry base name (relative to its containing directory)
    string name;
    
    /// True if an entry is a file
    bool isFile;
    
    /// True if an entry is a directory
    bool isDirectory;
}

/// A directory in the file system.
interface Directory
{
    /// 
    void close();

    /// Get directory contents as a range.
    /// This range $(I should) be lazily evaluated when practical.
    /// The entries "." and ".." are skipped.
    InputRange!DirEntry contents();
}

/// A filesystem limited to read access.
interface ReadOnlyFileSystem
{
    /** Get file or directory stats.
        Example:
        ---
        void printFileInfo(ReadOnlyFileSystem fs, string filename)
        {
            FileStat stat;

            writef("'%s'\t", filename);

            if (!fs.stat(filename, stat))
            {
                writeln("ERROR");
                return;
            }

            if (stat.isFile)
                writefln("%u", stat.sizeInBytes);
            else if (stat.isDirectory)
                writeln("DIR");

            writefln("  created: %s", to!string(stat.creationTimestamp));
            writefln("  modified: %s", to!string(stat.modificationTimestamp));
        }
        ---
    */
    bool stat(string filename, out FileStat stat);

    /** Open a file for input.
        Returns: a valid InputStream on success, null on failure
    */
    InputStream openForInput(string filename);

    /** Open a directory.
    */
    Directory openDir(string path);
}

/// A file system with read/write access.
interface FileSystem: ReadOnlyFileSystem
{
    // TODO: Use exceptions or not?
    
    /// File access flags.
    enum
    {
        read = 1,
        write = 2,
    }

    /// File creation flags.
    enum
    {
        create = 1,
        truncate = 2,
    }

    // TODO: Keep it this way? (strongly-typed)

    /** Open a file for output.
        Returns: a valid OutputStream on success, null on failure
    */
    OutputStream openForOutput(string filename, uint creationFlags);

    /** Open a file for input & output.
        Returns: a valid IOStream on success, null on failure
    */
    IOStream openForIO(string filename, uint creationFlags);

    //IOStream openFile(string filename, uint accessFlags, uint creationFlags);

    /** Create a new directory.
        Returns: true if a new directory was created
        Examples:
        ---
        fs.createDir("New Directory", false);
        fs.createDir("nested/directories/are/easy", true);
        ---
    */
    bool createDir(string path, bool recursive);

    // BROKEN API. Must define semantics for non-atomic move cases (e.g. moving a file to a different drive)
    //bool move(string path, string newPath);

    /** Permanently delete a file or directory.
    */
    bool remove(string path, bool recursive);
}

/**
    Find files in the specified directory

    Params:
    rofs = filesystem to scan
    baseDir = path to the base directory (if empty, defaults to current working directory)
    recursive = if true, the search will recurse into subdirectories

    Examples:
    ---
    void listImagesInDirectory(ReadOnlyFileSystem fs, string baseDir = "")
    {
        foreach (entry; fs.findFiles(baseDir, true)
                .filter!(entry => entry.isFile)
                .filter!(entry => !matchFirst(entry.name, `.*\.(gif|jpg|png)$`).empty))
        {
            writefln("%s", entry.name);
        }
    }
    ---
*/
InputRange!DirEntry findFiles(ReadOnlyFileSystem rofs, string baseDir, bool recursive)
{
    // Do some magic so that we don't have to keep our own stack

    import core.thread;

    //baseDir = normalizePath(baseDir);

    DirEntry entry;

    // findFiles insists on calling us back (it's recursive), but we can trap it in a Fiber
    auto search = new Fiber(delegate void()
    {
        findFiles(rofs, baseDir, recursive, delegate int(ref DirEntry de)
        {
            // save the data (D doesn't allow to yield it directly)
            // and jump outside of the .call() (see below)
            entry = de;
            Fiber.yield();

            // after resuming, return to findFiles for another round
            return 0;
        });

        // state becomes TERM after we're resumed after returning the last entry
    });

    return new DirRange(delegate bool(out DirEntry de)
    {
        // terminated before?
        if (search.state == Fiber.State.TERM)
            return false;

        // jumps into our search delegate
        search.call();

        // last entry had been returned last time?
        // (even findFiles didn't know until we returned to it again)
        if (search.state == Fiber.State.TERM)
            return false;

        de = entry;
        return true;
    });
}

private int findFiles(ReadOnlyFileSystem rofs, string baseDir, bool recursive, int delegate(ref DirEntry entry) dg)
{
    Directory dir = rofs.openDir(baseDir);

    if (dir is null)
        return 0;

    int result = 0;

    try
    {
        foreach (entry; dir.contents)
        {
            if (!baseDir.empty)
                entry.name = baseDir ~ "/" ~ entry.name;

            result = dg(entry);

            if (result != 0)
                return result;

            if (recursive && entry.isDirectory)
            {
                result = findFiles(rofs, entry.name, recursive, dg);

                if (result != 0)
                    return result;
            }
        }
    }
    
    finally
    {
        dir.close();
    }

    return result;
}

